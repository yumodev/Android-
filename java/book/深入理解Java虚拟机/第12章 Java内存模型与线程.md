[TOC]
### 12.1 概述

衡量一个服务性能的高低好坏，每秒事务处理数TPS 是最重要的指标之一。

### 12.2 硬件的效率与一致性

告诉缓存
内存一致性。

### 12.3 Java内存模型。Java Memory Model JMM

#### 12.3.1 主内存与工作内存

Java内存模型的主要是目标是定义程序中各个变量的访问规则。此处的变量指的是实例字段
静态字段和构成数组的对象的元素。
Java内存模型规定了所有的变量都存储在内存中。Main Memory中。每条线程都有自己的工作内存：Working Memory。线程的工作内存保存了被该线程使用到的变量的祝内存副本拷贝，线程对变量的所有的操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量。线程间的变量值的传递均需要通过主内存完成。

#### 12.3.2 内存间的交互操作。

一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节。
1、lock 锁定 ： 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
2、unlock解锁 :  作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他的线程锁定。
3、read 读取： 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
4、load 载入：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
5、use 使用：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个曹组。
6、assign 赋值：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机要到一个给变量赋值的字节码指令时执行这个操作。
7、store：作用域工作内存的变量，它把工作内存中的一个变量的值传送给主内存中，以便随后的write使用
8、write 写入：作用不主内存变量，它把store操作从工作内存得到的变量的值写入到主内存的变量中。

原则：
1、不允许：read和load、store和write操作之一的单独出现。
2、不允许一个线程丢弃它最近的assign操作，。
3、不允许一个线程无原因的将数据把数据从咸亨的工作内存同步到主内存中。
4、一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量。
5、一个变量在同一个时刻只允许一条线程对齐进行lock操作，但是一个lock操作，可以被统一线程重复执行多次。
6、对一个变量执行lock操作，将会情况工作内存中次变量的值，在执行引擎使用这个变流器前，需要重新执行load或者assign操作。
7、如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作。
8、如果一个变量执行unlock操作之前，必须先把次变量同步回主内存中。

#### 12.3.3 对于volatile变量的特殊规则

关键字volatile 是Java虚拟机提供的最轻量级的同步机制。
当第一个变量被定义成volatile之后，它将具备两种特性：第一是保证此变量对所有线程的可见性
volatile不保证是线程安全的。
我们在volatile与锁之间选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。

#### 12.3.4 double long

非原子性。

#### 12.3.5 原子性、可见性、有序性。

#### 12.3.6 先行发生原则

### 12.4 Java与线程。
####12.4.1 线程的实现
1、基于内核线程的实现
2、使用用户线程实现。
3、混合实现
4、Java线程的实现

#### 12.4.2 Java 线程的跳读。

协同式和抢占式。

#### 12.4.3 状态转换

新建、运行、无限等待、限期等待、阻塞、结束。





