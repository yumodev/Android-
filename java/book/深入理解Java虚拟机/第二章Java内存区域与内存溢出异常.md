[TOC]

### 2.1 概述

* java把内存控制权交给了java虚拟机，所有一旦出现内存泄露的情况，在不了解虚拟机的情况下是非常难以排查和解决问题的。

### 2.2 运行时数据区域

* 运行时内存区域：java虚拟机在执行java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。
   这些区域有各自的创建和销毁时间，以及不同的用途。
   
* 方法区、虚拟机栈、本地方法栈、堆、程序计数器
* 其中程序计数器、本地方法栈、虚拟机栈，是线程私有的。
* 方法区和Java堆、运行时常量池是线程私有的。

#### 程序计数器-Program Counter Register.
      
      Program Counter Register是一块比较小的内存区域，它可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。
      每个线程都有一个独立的程序计数器，各条线程之间计数器互不影响，程序计数器是线程私有的内存。
      如果线程执行的时一个Java方法，这个计数器记录的时正在执行的虚拟机字节码指令的地址；如果执行的时Native方法，这个计数器的值则为空，此内存区域是唯一一个在Java虚拟机中规范中没有规定任何OutOfMemoryError情况的区域。
      

#### Java虚拟机栈-Java Virtual Machine Stacks

       Java Virtual Machime Stacks 也是线程私有的，它的生命周期和线程相同。每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
       通常说的Java内存分为堆内存和栈内存。其中栈内存指的就是这块区域,也可以说成虚拟机栈中的局部变量表部分。
       局部变量表中存放了编译期可知的各种基本数据类型，对象引用类型（不同虚拟机有不同实现，一般为对象起始地址的引用指针）和returnAddress类型。
       其中64位长度的long和double类型会占据两个局部变量空间(Slot),其余的数据类型占据一个。局部变量表所需的内存空间在编译期间完成，当进入一个方法时，其局部变量的空间已经是完全固定了，在方法运行期间不会改变局部变量表的大小。
       当线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfmemoryErrory异常。
  
       
#### 本地方法栈-Native Methon Stacks

       Native Methon Stacks。为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定。在Sun  HotSpot虚拟机中，将本地方法栈和虚拟机栈合二为一，同样会抛出StackOverflowError和OutOfMemoryError异常。
       
#### java堆-Java Heap
  
         Java堆被所有线程共享，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配。     
	   Java堆是垃圾收集器管理的主要区域，很多时候成为GC堆（Garbage Collected Heap）
	   Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。可以通过-Xmx 和 -Xms控制。
	   
#### 方法区-Method Area

Method Area 与 Java堆一样，是各个线程共享的内存区域，它用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述成堆的一个逻辑部分，但是他有一个别名叫做Non-Heap
在HotSpot虚拟机上开发和部署程序的开发者来说，方法区被称为永久代。
HotSpot虚拟机将GC分代收集扩展至方法区，或者说使用永久代实现方法区。
Java虚拟机对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标是常量池的回收和对类型的卸载。
当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
	
#### 运行时常量池-Runtime Constant Pool

Runtime Constant Pool 是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
Java虚拟规范没有对运行时常量池做任何细节方面的要求。
运行时常量池相对于Class文件的常量池的另外一个重要特征是具备动态性。在运行期间也可以将新的常量放入池中。比如String类的intern()方法
常量池无法再申请到内存时会抛出OutOfmemoryError异常。
	
#### 直接内存
	
Direct Memory 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存被频繁使用，也可能导致OutOfMemoryError异常的出现。
在Jdk1.4加入的NIO类，引入了一种基于通道(Channer)和缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。
本机直接内存的分配不受到Java堆大小的限制，但是还是会受到本机总内存的限制。在服务器管理配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。
	
### 2.3 对象访问
	
对象访问在Java语言中无处不在，就是最普通的程序访问，也会涉及Java栈、Java堆、方法区三个最重要的内存区域。
	
```
Object obj = new Object();
```

`Object obj`这部分的语义将会放映到Java栈的本地变量表中，作为一个reference类型数据出现。
`new Object()`这部分语义将会反应到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存，这块内存的长度是不固定的。
在Java堆中还必须包括能找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。

Reference类型在Java虚拟机规范中规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位。主流的访问方式有两种：使用句柄和直接指针。

* 使用句柄
	
	Java堆中将会划出一块内存用来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据(Java堆)和类型数据(方法区)各自的具体地址信息
	
	使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄的实例数据指针，而reference本身不需要修改。
	
* 直接指针
	
	Java堆对象，考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象的地址。
	
	使用直接指针访问的方式最大的好处就是速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，所有这些开销积少成多也是非常开关的执行成功。Sun HotSpot采用的直接指针方式实现。
      

### 2.4 OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能。


#### 2.4.1 Java堆溢出

Java堆用于存储对象的实例，我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆的容量限制后产生内存溢出异常。
配置Vm options: -Xms -Xmx 。

#### 2.4.2 虚拟机栈和本地方法栈。

HotSpot虚拟机中并不区分虚拟机栈和本地方法栈。栈的容量有-Xss 在设定。
如果线程请求的栈深度大于虚拟机所有允许的最大深度，将抛出StackOverflowError
如果虚拟机在扩展栈时无法申请足够的内存空间，则抛出OutOfMemoryError。

#### 2.4.3 运行时常量池溢出

由于常量池分配在方法区，可以通过-XX:PermSize 和 -XX:MaxPermSize限制方法区的大小。
通过String.intern().

#### 2.4.4 方法区异常

生成大量的类来充满方法区，从而造成内存溢出。

#### 2.4.5 本机直接内存异常。

-XX:MaxDirectMemorySize 




