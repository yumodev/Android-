[TOC]

### 3.1 概述
* 为什么需要了解GC和内存分配

	当需要排查各种内存溢出和内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们需要对这些技术进行必要的监控和调节。
	
* 那些分区的内存需要回收？

	程序计数器、虚拟机栈、本地方法栈这几个区域的内存分配和回收都具备确定性，所有不需要过多考虑回收的问题，当方法或者线程结束时，内存自然就跟随者回收了。
	Java堆和方法区的内存分配和回收是动态的，GC关注的内存回收也是指这一部分。
	
###3.2 对象已死吗？

#####3.2.1 引用计数法（Reference Counting）

   给对象添加一个计数器，每当有一个地方引用它时，计数器值就加1；每当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能在被使用的。
   引用计数法，实现简单，效率高，但是很难解决对象之间的相互循环引用的问题。
       
##3.2.2 根搜索算法

GC Roots Tracing：通过一系列的名为 “GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径，成为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。

可以作为GC Roots的对象有：
1. 虚拟机栈(栈帧中本地变量表)中的引用对象，
2. 方法区中的类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中JNI的引用的对象。

##3.2.3 引用

当内存足够事，则能保留在内存中；在内存进行垃圾回收后还是内存不足，则可以抛弃这些对象。
#### 3.2.3.1 强引用

普通引用，比如new生成的对象。只要强引用关系还在，垃圾回收器永远不会回收掉被引用的对象。
#### 3.2.3.2 软引用

软件用主要是描述一些还有用，但是非必须的对象。在发生内存溢出之前，会对这些软引用对象进行二次回收，如果还是内存不足才会发生内存溢出。SoftReference
#### 3.2.3.3 弱引用

弱引用用来描述非必需的对象的，但是它的强度比软引用更弱一些，被荣引用关联的对象，只能生存在喜爱此垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否走狗，都会回收掉只被弱引用关联的对象。
WeakReference类来实现弱引用。

#### 3.2.3.4 虚引用

 虚引用成为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在我，安全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用的关联的唯一目的就是希望在这个对象被收集器回收时受到一个系统通知。PlantomReference类来实现虚引用。

### 3.2.4 生存还是死亡

   在跟搜索算法中不可达的对象，并非是非死不可的，它们处于缓刑阶段，要真正的宣告一个对象的死亡，至少需要两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机掉用过，虚拟机将这两种情况都视为没有必要执行finalize()方法。
      如果一个对象被判定为有必要执行Finalize()方法的对象，放入F-Queue队列中，然后由虚拟机建立的，低优先级的Finalizer线程去执行。虚拟机会触发finalize()方法，但不保证等待它运行结束，因为一个对象在finalize()执行非常慢，或者发生了死循环，就有可能导致F-Queue队列中的其他对象永久处于等待中泰，设置导致整个内存回收系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功解救自己，那么只要重新与引用链上的任何一个对象建立关联即可，但是它并不是总能成功解救自己。
      因为任何一个对象的finalize()方法都只被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。
	

## 3.2.5 回收方法区-永久代

   很多人认为在永久代中时没有垃圾收集的，Java虚拟机规范中确实说过可以不要钱虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的性价比一般比较低，在堆中，尤其是新生代中，常规应用进行一次垃圾收集，一般可以回收70%-95%的内存空间，而永久代的垃圾收集率远这个要低。
   永久代的垃圾收集主要回收内容为：废弃常量和无用的类。
   如何判定无用的类：
   1、该类的所有的实例都已经被回收。
   2、加载该类的ClassLoader已经被回收
   3、该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过发射访问该类的方法。
   
   在大量使用反射、动态代理、CGLib的地方和动态生成JSP和OSGI等频繁自定义ClassLoader的地方都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。
   
###  3.3垃圾收集算法

#### 3.3.1 标记-清除算法-Mark-Sweep算法

最基础的收集算法是标记-清除算法（Mark-Sweep）算法：首先标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

缺点：效率不高；空间问题，标记清除之后会产生大龄不连续的内存碎片。当程序运行时需要分配 较大对象时无法找到足够的连续内存而不得不提前触发另外的一次垃圾收集动作。

#### 3.3.2 复制算法---新生代。

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片的复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，不足之处在于相当于可供使用的内存缩小了一半。

现在商业虚拟机都采用这用手机算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所有并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的拷贝到另外的一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1。
由于没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存进行分配担保(Handle Promotion)。如果另外的一块Survivor空间没有足够的空间存放上一次新生收集下来的存活对象，九江这些对象通过分配担保机制，进入老年代。



#### 3.3.3 标记-整理算法-Mark-Compact老年代

在老年代中使用标记-整理(Mark-Compact)算法，其标记过程和标记-清除算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，然后直接清理掉端便捷意外的内存。

#### 3.3.4 分代收集算法-Generational Collection

Generational Collection 算法，只是根据对象的存活周期的不同将内存划分为几块。一般把Java堆分为新生代和老年代，可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象四区，只有少量存活，那就选用复制算法。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记-整理的算法。

### 3.4 垃圾收集器

Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因为每个厂家的垃圾收集器有可能有很大的区别。

####3.4.1 Serial 收集器-连续收集器

Serial收集器是最基本、历史最悠久的收集器，在1.3.1之前是虚拟机新生代收集的唯一选择。它是一个单线程收集器。单线程的并不意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程(Stop The World)，直到它收集结束。
Serial收集器目前依然是虚拟机运行在Client模式下的默认新生代收集器。它的有点就是简单和高效。在桌面的应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十M或者一两百M的新生代，停顿的时间完全可以控制在几十毫秒最对一百多毫秒以内。

####3.4.2 ParNew收集器-并行收集器

ParNew 收集器是Serial收集器的多线程版本，是许多运行在 Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有他能与CMS收集器配合工作。
是运行在Server模式下的首先新生代收集器。
ParNew收集器，是使用 -XX:+UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制制定它。
ParNew 在单CPU的情况下绝对不会被有比Serial收集器更好的效果。它默认开启的收集线程数与CPU的数量相同，在CPU非常多，比如32个的时候，可以使用-XX:ParallelLGCThreads参数来限制垃圾收集的线程数。

####3.4.3 Parallel Scavenge

也是属于新生代收集器，使用复制算法实现，同时也是并行的多线程收集器。
CMS等收集器的关注点尽可能的缩短垃圾收集时用户线程的停顿时间，Paraller Scavenge收集器的特点是达到一个可控制的吞吐量。吞吐量是cpu用于运行用户代码的时间和cpu总消耗的时间的比值，即吞吐量=运行用户代码的时间/运行用户代码的时间+垃圾收集时间。
  停顿时间越短越合适需要与用户交互的程序，但是高吞吐量则可以高效率的使用CPU的时间，尽快的完成程序的运算任务，主要合适在后台运算而不需要太多交互的程序。
  
  Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio.
  MaxGCPauseMillis允许设置一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GC停顿时间缩短是以新生吞吐量和新生代空间来换取的。
  GCTimeRatio参数的值应当是一个0-100的整数，也就是垃圾收集收件占总时间的比率，相当于吞吐量的倒数。
  默认值是99 ，也是允许最大1%的收集时间(1/(1+99)) 的垃圾收集时间。
  -XX:+UseAdaptiveSizePolicy值得关注，是一个开关参数，当这个参数打开之后，就不需要手工指定新生代代销、Eden、Survivor的细节参数了，虚拟机会根据当前系统的运行状况手机性能监控信息，动态调整这些参数，以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为GC自使用调节策略。(GC-Ergonomics)
  
####3.4.4 Serial Old收集器

Serial收集器的老年代版本，也是一个单线程收集器。使用标记-整理算法。这个收集器主要在Client模式下地虚拟机中使用。
在Server模式下它有两大用途，在JDK1.5及以前版本中与Parallel Scavenge收集器搭配使用，另外一个当做CMS收集器的后辈预案，在并发手机发生ConcurrentModeFailure的时候使用。
在1.6以前，如果在新生代选择了使用ParallerScavenge收集器后，那么老年代就只能使用Serial Old收集器。

####3.4.5 Parallel Old 收集器。

Paraller收集器的老年代版本，使用多线程和标记-整理算法，在1.6中才出现，用于配合新生代的Paraller Scavenge收集器。
在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器的方案。

#### 3.4.6 CMS收集器-Concurrent Mark Sweep收集器
Concurrent Mark Sweep收集器是一种以获取最短停顿时间的为目标的收集器，基于标记-清除算法实现。其整个过程分为四步
1. 开始标记 CMS initial mark
2. 并发标记 CMS concurrent mark
3. 重新标记 CMS remark
4. 并发清楚 Cms concurrent sweep


在初始标记和重新标记阶段还是需要 线程停顿的。初始标记仅仅标识一个GC Roots等直接关联到的对象，速度很快。并发标记阶段就是进程GC Roots Tracing的过程，而重新标记就是为了修正并发标记期间，用户线程仅需运作导致标记发生变动的那一部分的标记记录，这个阶段的停顿一般比初始标记稍长，远小于并发标记时间。
整个过程耗时最长的是并发标记和并发清除过程中。

CMS是一款优秀的手机的，它的最主要优点就是并发收集、低停顿。
它有三个缺点。
1、对CPU资源非常敏感。
2、CMS收集器无法处理浮动垃圾。
3、产生大量碎片。因为CMS基于 标记-清除 算法实现的收集器。 -XX:+UseCMSCompactAtFullCollection开关的参数用于在FullGC服务之后进行一个碎片整理工程。-XX:CMSFullGCsBeforeCompaction 用于设置在执行多少次不压缩的FullGC后，跟着来一次带压缩的。

#### 3.4.7 G1 收集器

Garbage First收集器是当前收集器技术发展的最前沿成果。
G1收集器是基于标记-整理的算法实现的收集器，不会产生碎片。
G1收集器可以非常准确的控制停顿，可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。
G1收集器可以在实现基本不牺牲吞吐量的前提下进行低停顿的内存回收，这是由于它极力避免全区域的垃圾收集。G1将整个Java堆划分为新生代、老年代划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积成都，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。

### 3.5 内存分配和回收策略。

对象的内存分配，就是在堆上分，对象主要分配在新生代的Eden区上，如果启动了本地线程缓冲，将按照线程优先在TLAB上分配。

#### 3.5.1 对象优先在Eden上分配。

对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC。
新生代GC（MinorGC） ：发生在新生代的垃圾收集动作。
老年底GC（MajorGC/Full GC） ：出现MajorGC时，经常会伴随一次MinorGC。

#### 3.5.2 大对象直接进入老年代

大对象就是指，需要大量连续内存空间的Java对象，最典型的大UI讲就是那种很惨个的字符串及数组，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来安置他们。
虚拟机听了-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配，这样做的目的是避免在Eden区以及两个Survivor区之间发生大量的内存拷贝。

#### 3.5.3 长期存活的对象将进入老年代

对象年龄计数器，当年龄增加到一定程度(默认是15)的时候，就会将其放入到老年代中。
-XX:MaxThenuringThreshold 设置老年代的年龄。

#### 3.5.4 动态对象的年龄判定。

如果在Sruvivor空间中的相同年龄所有对象的大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入到老年代中，无须等到MaxTenuringThreshold中要求的年龄。

#### 3.5.5 空间分配担保

在发生MinorGC时，虚拟机会检测之前每次今生到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次FullGC。如果小于，则查看HandlePromotionFailture设置是否允许担保失败，如果允许，那只会进行MinorGC，如果不允许，则也要改为进行一次Full GC。

