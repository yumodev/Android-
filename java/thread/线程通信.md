### 线程通信


### 通过共享对象通信

### 忙等待

### wait, notify, notifyAll()

Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object类定义了三个方法：wait,notify, notifyAll()来实现这个机制。
一个线程调用了任意对象的wait()的方法，就会变成非运行状态，直到另外一个线程调用了同一个对象的notify()方法。线程必须在同步块里调用wait()和notify()。如果一个线程如果没有持有对象锁，将不能调用wait(),notify()或者notifyAll()，否则，会抛出。IllegalMOnitorStateException异常。一旦线程调用了wait()方法，它就释放 了所持有的监视器对象上的锁，这将允许其他线程也可以调用wait()或者notify()
一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()方法的调用。因为wait()方法运行在同步块里面，如果多个线程被nofityAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出Wait()前必须获得监视器对象的锁。

### 丢失的信号

如果一个线程先于被通知的线程调用wait()前调用了notify()，等待的线程将错过这个信号，就有可能使该线程永远在等待。

### 假唤醒（spurious wakeups）

由于一些未知的原因，线程有可能在未接收到唤醒信号以前，就醒了过来。可以通过自旋锁解决这个问题，但是会消耗性能太大。

### 多个线程 等待相同的信号

### 不要在字符串常量或者全局对象中调用wait()





### 参考
[线程通信](http://ifeve.com/thread-signaling/)


