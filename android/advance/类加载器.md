### Android-ClassLoader

动态加载的基础是ClassLaoder。ClassLoader就是专门用来处理类加载工作的，所以这货也是类加载器，而且一个运行中的APp，不仅只有一个类加载器。
在Andorid系统启动的，会加载一个Boot类型的ClassLaoder的实例，用于加载一些系统的FrameWork层级需要的类。
App启动的时候，会创建自己的ClassLaoder实例，用于加载在即dex文件中的类。
一个运行中的APP至少有两个加载器：dalvik.system.PathClassLoader和BootClassLoader。

如果希望通过动态加载的方式，加载一个新版本的dex文件，使用里面的新类替换原有的旧类，从而修复原有类的bug，那么你必须保证在加载新类的时候，旧类还没有被加载，因为如果已经加载过旧的dex文件，那么新的的ClassLoadder就会一直优先使用旧类，如果旧类总是优先于新类被加载，我们也可以使用一个与加载旧类的ClassLaoder没有树的继承关系的另一个classLaoder来加载新类，因为ClassLaoder只会检查其Parent有没有家再过当前要加载的类，如果两个ClassLaoder没有继承关系，那么旧类和新类都能被加载。
在Java中，只有当两个实例的类型、包名和加载器的ClassLoader一致都相同，才会被认为是同一种类型，但是上面的方式虽然包名和类名一样，但是由于ClassLaoder不一样，所以并不是同一种类型，在应用中可能出现类型不符异常。

#### Android的类加载器

* BaseDexClassLoader
* DexClassLoader
* BootClassLoader
* PathClassLoader
* URLClassLoader

#### DexClassLaoder和PathClassLoader

ClassLaoder是一个抽象类，在实际运用中，我们可以使用DexClassLaoder和PathClassLoader这些类加载器进行加载。他们的不同之处在于，DexClassLaoder可以加载Jar/apk/dex 可以冲SD卡中加载未安装的APK
，PathClassLaoder只能加载系统中已经安装过的APK。







